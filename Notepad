Design Notepad for Desktop:

1.key takeaways in this video:
  - when not to use strategy
  - when not to use singleton
  

thought process: 
 Entity: 
  - Text Editor
  - Cursor
  - Document
  - clipboard

 Service functions:
  - loadDocument()
  - saveDocument()
  - closeDocument()
  - selectText()
  - copy()
  - cut()
  - paste()
  - moveCursor()


1.1 TextEditor
Responsibility: facede class for user interactions, delegations to other components.

Key Reasoning:
Does not store text directly — delegates to Document.
SRP maintained — only coordinates actions, not implementing them.

Key Methods:

  - openDocument(filePath)
  - saveDocument(filePath)
  - moveCursor(line, column)
  - select(rowStart, rowEnd)
  - copy(rowStart, rowEnd)
  - cut(rowStart, rowEnd)
  - paste(line)

Design Pattern Role: Acts as the client in the Command Pattern.

1.2 Document (Abstract Base Class)
Responsibility: Stores text and manages file operations.

Variants:
 - ListDocument (list of strings)
 - RopeDocument (rope data structure)
 - PieceTableDocument (piece table model)

Reasoning:
 Each document type manages its own storage and load/save logic.
 Future document types don’t require changes in TextEditor.

Key Methods:

 - load(filePath) – abstract
 - save(filePath) – abstract
 - getLines(start, end)
 - removeLines(start, end)
 - insertLines(position, lines)

Design Pattern Role:

Template Method can be applied here for file I/O (see Step 7).

1.3 Cursor
Responsibility: Manages current position and selection state.
Reasoning:
Keeps TextEditor free from low-level cursor logic.

 - Easy to extend in the future (e.g., column-based selection).

Key Methods:
 - move(line, column)
 - select(rowStart, rowEnd)
 - clearSelection()

Design Pattern Role: None directly, but respects SRP.

1.4 Clipboard
Responsibility: Stores copied or cut content temporarily.

Reasoning:
Keeps clipboard logic separate from TextEditor.
In future, can support multiple clipboard history stacks.

Key Methods:
 - setContent(lines)
 - getContent()

Design Pattern Role: Can be a Singleton if we want one clipboard per app instance.

1.5 Command Pattern
Responsibility: Encapsulates each user action as a command.

Reasoning:

 - Allows undo/redo functionality.
 - Keeps operations loosely coupled.

Example Commands:

 - CopyCommand, CutCommand, PasteCommand, MoveCursorCommand

Structure:

 - execute() — perform the action.

 - undo() — rollback the action.

2. Key Arguments & Decisions
2.1 No Singleton Needed for Document
Reasoning:

We are not allowing concurrent editing of the same document.
Multiple users can open different documents simultaneously.
Each document instance is independent.

Singleton would restrict flexibility unnecessarily.

2.2 Command Pattern Justification
Every operation (cut, copy, paste, move) becomes a command object.

Enables:
 - Undo/redo
 - Operation logging

Macro recording

Keeps TextEditor clean by delegating action logic to commands.

2.3 Clipboard as Singleton – Optional
 - If we want one global clipboard per app session, we can make it Singleton.
 - If we want per-document clipboard, no Singleton is needed.

3. Special SRP Reasoning
moveCursor: Delegated to Cursor so changes to movement logic don’t affect TextEditor.

 - select: Delegated to Cursor so different selection models can be added later.
 - copy: TextEditor only orchestrates; Document and Clipboard hold the logic.
 - cut: Clipboard + Document changes are transactional.

If one fails, rollback the other.

Could use Command Pattern to wrap this in a reversible operation.

4. Template Method Pattern in Document
Where Used:
File I/O operations (load/save).

Why Used:
Process for saving is:

 - Open file
 - Write header (optional, varies per format)
 - Write content
 - Write footer (optional)
 - Close file

Fixed skeleton, but variable steps for different file formats.

Benefits:
  Consistency: All document types follow the same open → write → validate → close structure.
  Code Reuse: Common steps implemented once in base class.
  Extensibility: New file types only override the steps that differ.

Remember These Key Arguments:
  If tomorrow you need to add logging or metrics to the process, you do it once in the base class, and all document types benefit automatically.
  To add support for a new file format, you don’t rewrite the whole load/save logic — just override the few “variable” steps.

5. Transactional Safety
  Template Method ensures that if a step fails, we can abort and leave the file in a consistent state.
  Can also integrate with Command Pattern for undoable file save operations.



code:

// ===============================================
// Text Editor LLD
// Patterns Used:
// 1. Command Pattern -> For undo/redo and encapsulating operations
// 2. Template Method Pattern -> For load/save in different document types
// =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================
   =============================================================================================================================================



                ┌───────────────────────────┐
                │       TextEditor           │
                ├───────────────────────────┤
                │ - document: Document       │
                │ - cursor: Cursor           │
                │ - clipboard: Clipboard     │
                │ - history: CommandHistory  │
                ├───────────────────────────┤
                │ + executeCommand(cmd)      │ Executes and stores command
                │ + moveCursor(row)          │ Delegates to Cursor
                │ + select(start, end)       │ Delegates to Cursor
                │ + copy(start, end)         │ Orchestrates copy
                │ + cut(start, end)          │ Orchestrates cut
                │ + paste(row)               │ Orchestrates paste
                └───────────────────────────┘
                          ▲
                          │ Uses

                ┌───────────────────────────┐
                │        Document (abstract) │  <<Template Method>>
                ├───────────────────────────┤
                │ - content                  │
                ├───────────────────────────┤
                │ + load(filePath)           │ Template method for load
                │ + save(filePath)           │ Template method for save
                │ # readData(path)           │ Abstract step
                │ # writeData(path)          │ Abstract step
                │ + getLines(start, end)     │ Returns lines
                │ + removeLines(start, end)  │ Removes lines
                │ + insertLines(pos, lines)  │ Inserts lines
                └───────────────────────────┘
                  ▲                   ▲
   ┌───────────────────────┐  ┌───────────────────────┐
   │   ListDocument         │  │ RopeDocument          │
   ├───────────────────────┤  ├───────────────────────┤
   │ + readData(path)       │  │ + readData(path)       │
   │ + writeData(path)      │  │ + writeData(path)      │
   └───────────────────────┘  └───────────────────────┘

   ┌───────────────────────┐
   │ Cursor                │
   ├───────────────────────┤
   │ - position            │
   │ - selectionRange      │
   ├───────────────────────┤
   │ + move(row)           │ Moves cursor
   │ + select(start, end)  │ Selects rows
   └───────────────────────┘

   ┌───────────────────────┐
   │ Clipboard             │
   ├───────────────────────┤
   │ - content             │
   ├───────────────────────┤
   │ + setContent(text)    │ Stores copied text
   │ + getContent()        │ Returns stored text
   └───────────────────────┘

   ┌───────────────────────┐
   │ Command (interface)   │   <<Command Pattern>>
   ├───────────────────────┤
   │ + execute()           │ Executes the operation
   │ + undo()              │ Reverts the operation
   └───────────────────────┘
         ▲
   ┌───────────────┬──────────────────────┬──────────────────────┐
   │ CopyCommand    │ CutCommand           │ PasteCommand         │
   │ + execute()    │ + execute()          │ + execute()          │
   │ + undo()       │ + undo()             │ + undo()             │
   └───────────────┴──────────────────────┴──────────────────────┘

   ┌───────────────────────┐
   │ CommandHistory        │
   ├───────────────────────┤
   │ - historyStack        │
   ├───────────────────────┤
   │ + push(cmd)           │ Stores executed command
   │ + pop()               │ Retrieves last command
   └───────────────────────┘


=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================
=============================================================================================================================================


// ===== Command Pattern Core =====


// Receiver classes
class Document {
    private List<String> lines = new ArrayList<>();

    public void insertLine(int index, String text) {
        lines.add(index, text);
    }

    public void deleteLine(int index) {
        lines.remove(index);
    }

    public String getLine(int index) {
        return lines.get(index);
    }

    public List<String> getLines() {
        return new ArrayList<>(lines);
    }

    public void setLines(List<String> newLines) {
        lines = new ArrayList<>(newLines);
    }

    public void print() {
        for (int i = 0; i < lines.size(); i++) {
            System.out.println((i + 1) + ": " + lines.get(i));
        }
    }
}

interface Command {
    void execute();
    void undo();
}

// Concrete Command: Insert
class InsertCommand implements Command {
    private Document document;
    private int index;
    private String text;

    public InsertCommand(Document document, int index, String text) {
        this.document = document;
        this.index = index;
        this.text = text;
    }

    @Override
    public void execute() {
        document.insertLine(index, text);
    }

    @Override
    public void undo() {
        document.deleteLine(index);
    }
}

// Concrete Command: Delete
class DeleteCommand implements Command {
    private Document document;
    private int index;
    private String deletedText;

    public DeleteCommand(Document document, int index) {
        this.document = document;
        this.index = index;
    }

    @Override
    public void execute() {
        deletedText = document.getLine(index);
        document.deleteLine(index);
    }

    @Override
    public void undo() {
        document.insertLine(index, deletedText);
    }
}

// Invoker: TextEditor
class TextEditor {
    private Document document;
    private Stack<Command> undoStack = new Stack<>();
    private Stack<Command> redoStack = new Stack<>();

    public TextEditor(Document document) {
        this.document = document;
    }

    // Executes a command and stores it for undo
    public void executeCommand(Command command) {
        command.execute();
        undoStack.push(command);
        redoStack.clear();
    }

    public void undo() {
        if (!undoStack.isEmpty()) {
            Command command = undoStack.pop();
            command.undo();
            redoStack.push(command);
        }
    }

    public void redo() {
        if (!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            command.execute();
            undoStack.push(command);
        }
    }

    public void printDocument() {
        document.print();
    }
}

// ===== Template Method Pattern Core =====
abstract class AbstractDocument {
    protected List<String> content = new ArrayList<>();

    // Template method
    public final void load(String path) {
        openFile(path);
        readContent();
        validate();
        closeFile();
    }

    public final void save(String path) {
        openFile(path);
        writeContent();
        validate();
        closeFile();
    }

    // Common step - implemented once
    protected void openFile(String path) {
        System.out.println("Opening file: " + path);
    }

    protected void closeFile() {
        System.out.println("Closing file");
    }

    // Steps to be implemented by subclasses
    protected abstract void readContent();
    protected abstract void writeContent();
    protected abstract void validate();
}

// Concrete Document Type - Text File
class TextFileDocument extends AbstractDocument {
    @Override
    protected void readContent() {
        System.out.println("Reading content from text file");
    }

    @Override
    protected void writeContent() {
        System.out.println("Writing content to text file");
    }

    @Override
    protected void validate() {
        System.out.println("Validating text file format");
    }
}

// ===== Example Usage =====
public class Main {
    public static void main(String[] args) {
        // Command Pattern in action
        Document doc = new Document();
        TextEditor editor = new TextEditor(doc);

        editor.executeCommand(new InsertCommand(doc, 0, "Hello World"));
        editor.executeCommand(new InsertCommand(doc, 1, "This is a text editor"));
        editor.printDocument();

        System.out.println("Undoing last action...");
        editor.undo();
        editor.printDocument();

        System.out.println("Redoing last action...");
        editor.redo();
        editor.printDocument();

        // Template Method Pattern in action
        AbstractDocument textDoc = new TextFileDocument();
        textDoc.load("file.txt");
        textDoc.save("file.txt");
    }
}

/*
=======================
Where Command Pattern is used:
- InsertCommand, DeleteCommand implement Command interface
- Each command encapsulates both "do" and "undo" logic
- TextEditor acts as Invoker, maintains undo/redo stacks
=======================
Where Template Method Pattern is used:
- AbstractDocument defines fixed algorithm for load/save
- Subclasses (e.g., TextFileDocument) provide specific read/write/validate implementations
- Common steps (openFile, closeFile) are implemented once
=======================
*/

  
